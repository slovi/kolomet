package cz.kolomet.util.web.ajax;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
import org.springframework.web.method.support.ModelAndViewContainer;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver;
import org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;

import cz.kolomet.service.exception.CommonServiceException;
import cz.kolomet.service.exception.Ignored;

/**
 * Handler class used for handling Ajax and standard requests to the application. Class is needed to be added to
 * application context. Response to Ajax is generated by private <DefaultJsonErrorObjectFactory> but can be overriden by
 * class which implements <JsonErrorObjectFactory> interface.
 * 
 * @author JS
 * 
 */
public class AjaxHandlerExceptionResolver extends AbstractHandlerExceptionResolver {

	private static final int DEFAULT_ERROR_CODE = 1000;

	private static final int AJAX_HANDLER_EXCEPTION_RESOLVER_ORDER = -10;

	private final List<HttpMessageConverter<?>> messageConverters;

	public AjaxHandlerExceptionResolver() {

		this.messageConverters = new ArrayList<HttpMessageConverter<?>>();
		this.messageConverters.add(new MappingJackson2HttpMessageConverter());

		setOrder(AJAX_HANDLER_EXCEPTION_RESOLVER_ORDER);
	}

	@Override
	protected boolean shouldApplyTo(final HttpServletRequest request, final Object handler) {
		return super.shouldApplyTo(request, handler) && isAjaxRequest(request, handler);
	}

	@Override
	protected ModelAndView doResolveException(final HttpServletRequest request, final HttpServletResponse response,
			final Object handler, final Exception ex) {

		final ServletWebRequest webRequest = new ServletWebRequest(request, response);
		final ModelAndViewContainer mavContainer = new ModelAndViewContainer();

		int code = DEFAULT_ERROR_CODE;
		if (ex instanceof CommonServiceException) {
			code = ((CommonServiceException) ex).getErrorNr();
		}
		final Object ajaxResponse = AjaxResponse.error(code, ex);
		final HandlerMethodReturnValueHandler returnValueHandler = new RequestResponseBodyMethodProcessor(messageConverters);
		try {
			
			response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			
			returnValueHandler.handleReturnValue(ajaxResponse, null, mavContainer, webRequest);
			if (!mavContainer.isRequestHandled()) {
				throw new RuntimeException(
						"Error in AjaxHandlerExceptionHandler.");
			}
			return new ModelAndView();
		} catch (final Exception e) {

			throw new RuntimeException(
					"Error in AjaxHandlerExceptionHandler.", e);
		}
	}
	
	@Override
	protected void logException(Exception ex, HttpServletRequest request) {
		if (ex instanceof Ignored) {
			logger.warn(ex.getLocalizedMessage());
		} else {
			logger.error(ex, ex);
		}
	}

	// Not sure if this method is implemented properly
	protected boolean isAjaxRequest(final HttpServletRequest request, Object handler) {
		
		if (handler instanceof HandlerMethod) {
			return ((HandlerMethod) handler).getMethod().getAnnotation(ResponseBody.class) != null;
		} else {
			return false;
		}
	}

}
